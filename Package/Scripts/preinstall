#!/usr/bin/osascript -lJavaScript

ObjC.import('stdlib');

class MachOBinary {
  /**
   * @param {string} path
   */
  constructor(path) {
    const url = $.NSURL.fileURLWithPath(path);
    const error = $();
    const data = $.NSData.dataWithContentsOfURLOptionsError(url, 0, error);
    if (data.isNil()) {
      throw new Error(error.description.js);
    }
    this.bytes = data.bytes;
    this.offset = 0;
    this.parse();
  }

  parse() {
    const magic = this.readInt32BE();
    switch (magic) {
      case 0xcafebabe >> 0:
        this.fatHeader();
        break;
      case 0xcafebabf >> 0:
        this.fatHeader();
        break;
      default:
        this.offset -= 4;
        const mach = this.machMagic();
        this.archs = [{mach}];
        break;
    }
  }

  fatHeader() {
    const nfatArch = this.readInt32BE();
    const offset = this.offset;
    this.archs = new Array(nfatArch);
    for (let i = 0; i < nfatArch; i++) {
      this.offset = offset;
      this.archs[i] = this.fatArch();
    }
  }

  fatArch() {
    const cpuType = this.readInt32BE();
    const cpuSubtype = this.readInt32BE();
    const offset = this.readInt32BE();
    const size = this.readInt32BE();
    const align = this.readInt32BE();
    this.offset = offset;
    const mach = this.machMagic();
    return {
      cpuType,
      cpuSubtype,
      offset,
      size,
      align,
      mach,
    };
  }

  machMagic() {
    const magic = this.readInt32LE();
    switch (magic) {
      case 0xfeedface >> 0:
        return this.machHeader();
      case 0xfeedfacf >> 0:
        return this.machHeader(64);
      default:
        throw new Error(`Unknown mach magic: ${magic}`);
    }
  }

  machHeader(bits = 32) {
    const cputype = this.readInt32LE();
    const cpusubtype = this.readInt32LE();
    const filetype = this.readInt32LE();
    const ncmds = this.readInt32LE();
    const sizeofcmds = this.readInt32LE();
    const flags = this.readInt32LE();
    if (bits === 64) {
      this.readInt32LE(); // reserved
    }
    const loadCommands = new Array(ncmds);
    for (let i = 0; i < ncmds; i++) {
      loadCommands[i] = this.loadCommand();
    }
    return {
      cputype,
      cpusubtype,
      filetype,
      ncmds,
      sizeofcmds,
      flags,
      loadCommands,
    };
  }

  loadCommand() {
    const loadCommand = {
      cmd: this.readInt32LE(),
      cmdsize: this.readInt32LE(),
    };
    switch (loadCommand.cmd) {
      case 0x8000001C >> 0: // LC_RPATH
        return this.rpathCommand(loadCommand.cmdsize);
      default:
        this.offset += loadCommand.cmdsize - 8;
        return loadCommand;
    }
  }

  rpathCommand(cmdsize) {
    const offset = this.readInt32LE();
    const rpath = this.readString(cmdsize - offset);
    return { offset, rpath };
  }

  /**
   * @return {Ref}
   */
  readInt32BE() {
    return (
      this.bytes[this.offset++] << 24 |
      this.bytes[this.offset++] << 16 |
      this.bytes[this.offset++] << 8 |
      this.bytes[this.offset++]
    );
  }

  /**
   * @return {Ref}
   */
  readInt32LE() {
    return (
      this.bytes[this.offset++] |
      this.bytes[this.offset++] << 8 |
      this.bytes[this.offset++] << 16 |
      this.bytes[this.offset++] << 24
    );
  }

  /**
   * @param {number} length
   * @return {string}
   */
  readString(length) {
    const bytes = this.readBytes(length);
    const firstNullCharacterIndex = bytes.indexOf(0);
    return String.fromCharCode(...bytes.subarray(0, firstNullCharacterIndex));
  }

  /**
   * @param {number} length
   * @return {Ref}
   */
  readBytes(length) {
    const bytes = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      bytes[i] = this.bytes[this.offset++];
    }
    return bytes;
  }
}

/**
 * @file Pre-install script for `xcnew`.
 *
 * It retouches rpath in `xcnew` executable to be suitable for the user's environment.
 *
 * @see {@link /var/log/install.log} for runtime log.
 */

const process = {
  /**
   * @return {{[key: string]: string}}
   */
  get env() {
    return ObjC.deepUnwrap($.NSProcessInfo.processInfo.environment);
  }
};

/**
 * @param {NSPipe} pipe
 * @param {string} encoding
 * @return {Ref|string}
 */
function readPipe(pipe, encoding) {
  const error = $();
  const data = pipe.fileHandleForReading.readDataToEndOfFileAndReturnError(error);
  if (data.isNil()) {
    throw new Error(error.description.js);
  }
  if (!encoding) {
    return data.bytes;
  }
  const cfStringEncoding = $.CFStringConvertIANACharSetNameToEncoding($(encoding));
  if (cfStringEncoding == $.kCFStringEncodingInvalidId) {
    return data.bytes;
  }
  const nsStringEncoding = $.CFStringConvertEncodingToNSStringEncoding(cfStringEncoding);
  const string = $.NSString.alloc.initWithDataEncoding(data, nsStringEncoding);
  return string.js;
}

/**
 * @param {string} file
 * @param {string[]} args
 * @param {object} options
 * @param {string} options.encoding
 * @return {Ref|string}
 */
function execFileSync(file, args = [], options = {}) {
  const task = $.NSTask.new;
  task.executableURL = $.NSURL.fileURLWithPath(file);
  task.arguments = args;
  task.standardOutput = $.NSPipe.pipe;
  task.standardError = $.NSPipe.pipe;
  const error = $();
  if (!task.launchAndReturnError(error)) {
    throw new Error(error.description.js);
  }
  task.waitUntilExit;
  const stdout = readPipe(task.standardOutput, options.encoding);
  const stderr = readPipe(task.standardError, options.encoding);
  const status = task.terminationStatus;
  if (status != 0) {
    const error = new Error(`Command failed: ${file}`);
    error.stdout = stdout;
    error.stderr = stderr;
    error.status = status;
    throw error;
  }
  return stdout;
}

/**
 * @param {string} developerDir
 * @return {boolean}
 */
function isDeveloperDirInXcode(developerDir) {
  const possibleInfoPlistURL = $.NSURL.fileURLWithPath(`${developerDir}/../Info.plist`);
  const infoPlist = $.NSDictionary.dictionaryWithContentsOfURLError(possibleInfoPlistURL, null);
  if (infoPlist.isNil()) {
    return false;
  }
  const bundleId = infoPlist.objectForKey('CFBundleIdentifier').js;
  return bundleId === 'com.apple.dt.Xcode';
}

/**
 * @param {string} file
 * @return {string[]}
 */
function getRpaths(file) {
  const binary = new MachOBinary(file);
  return binary.archs[0].mach.loadCommands.flatMap(c => c.rpath || []);
}

const developerDir = execFileSync('/usr/bin/xcode-select', ['--print-path'], {encoding: 'utf-8'}).trimEnd();
if (!isDeveloperDirInXcode(developerDir)) {
  throw new Error('Developer directory must be in Xcode.app.');
}
const installerPayloadDir = process.env['INSTALLER_PAYLOAD_DIR'];
if (!installerPayloadDir) {
  throw new Error('Environment variable $INSTALLER_PAYLOAD_DIR not found.');
}
const xcnewPath = installerPayloadDir + '/usr/local/bin/xcnew';
for (const oldRpath of getRpaths(xcnewPath)) {
  const newRpath = developerDir + oldRpath.split('/Contents/Developer', 2)[1];
  execFileSync('/usr/bin/install_name_tool', ['-rpath', oldRpath, newRpath, xcnewPath], {encoding: 'utf-8'});
}
$.exit(0);
