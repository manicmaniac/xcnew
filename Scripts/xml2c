#!/usr/bin/env python3

import argparse
import collections
import functools
import io
import shutil
import textwrap
import xml.etree.ElementTree as etree


Option = collections.namedtuple('Option', 'short long dest nargs help')
Arg = collections.namedtuple('Option', 'name required help')


class Mdoc(object):
    def __init__(self, f):
        self.manpage = etree.parse(f).getroot()

    @property
    def prog(self):
        return self.manpage.find('names/name').text

    @property
    def desc(self):
        return self.manpage.find('names/name/desc').text

    @property
    @functools.lru_cache
    def options(self):
        options = []
        for node in self.manpage.findall('usage/flag'):
            short = node.text
            long = node.find('long').text
            help = node.find('desc').text
            arg_node = node.find('arg')
            if arg_node is None:
                nargs, dest = 0, ''
            else:
                nargs, dest = 1, arg_node.text
            # action = argparse.Action([f'-{short}', f'--{long}'], dest, nargs=nargs, help=help)
            option = Option(short, long, dest, nargs, help)
            options.append(option)
        return options

    @property
    @functools.lru_cache
    def args(self):
        args = []
        for node in self.manpage.findall('usage/arg'):
            name = node.text
            required = (node.attrib.get('optional', '0') != '1')
            nargs = int(required)
            help = node.find('desc').text
            # action = argparse.Action([], name, required=required, nargs=nargs, help=help)
            arg = Arg(name, required, help)
            args.append(arg)
        return args


class GetoptFormatter(object):
    def __init__(self, path, prog, desc, options, args, prefix):
        self.path = path
        self.help_formatter = HelpFormatter(prog, desc, options, args)
        self.options = options
        self.args = args
        self.prefix = prefix

    def format_header(self):
        return textwrap.dedent("""\
            /*
             * This file is generated from {} with xml2c.
             * DO NOT edit this file directly.
             */

            #include <getopt.h>
            """).format(self.path)

    def format_help(self):
        help_lines = self.help_formatter.format_help().splitlines()
        lines = []
        for i, line in enumerate(help_lines):
            if i == 0:
                line = f'const char {self.prefix}Help[] = "{line}\\n"'
            elif i == len(help_lines) - 1:
                line = '                           "{}";\n'.format(line)
            else:
                line = '                           "{}\\n"'.format(line)
            lines.append(line)
        return '\n'.join(lines)

    def format_short_options(self):
        chars = ''
        for option in self.options:
            chars += option.short
            if option.nargs != 0:
                chars += ':'
        return f'const char {self.prefix}ShortOptions[] = "{chars}";\n'

    def format_long_options(self):
        lines = [f'const struct option {self.prefix}LongOptions[] = {{']
        for option in self.options:
            flag = 'no_argument' if option.nargs == 0 else 'required_argument'
            lines.append(f"""    {{"{option.long}", {flag}, NULL, '{option.short}'}},""")
        lines.append('    {NULL, 0, NULL, 0},')
        lines.append('};\n')
        return '\n'.join(lines)

    def format_c_source(self):
        return '\n'.join([
            self.format_header(),
            self.format_help(),
            self.format_short_options(),
            self.format_long_options()
        ])


class HelpFormatter(argparse.HelpFormatter):
    def __init__(self, prog, desc, options, args):
        super().__init__(prog, indent_increment=4, max_help_position=30)
        options = [self.option_to_action(option) for option in options]
        args = [self.arg_to_action(arg) for arg in args]
        self.add_text(f'{self._prog} - {desc}\n')
        self.add_usage(None, options + args, [], prefix='Usage: ')
        self.start_section('Options')
        self.add_arguments(options)
        self.end_section()
        self.start_section('Arguments')
        self.add_arguments(args)
        self.end_section()

    def format_help(self):
        return super().format_help()

    @staticmethod
    def option_to_action(option):
        return argparse.Action(['-' + option.short, '--' + option.long],
                               option.dest, nargs=option.nargs,
                               help=option.help)

    @staticmethod
    def arg_to_action(arg):
        return argparse.Action([], arg.name, nargs=int(arg.required), required=arg.required, help=arg.help)

    def _format_actions_usage(self, actions, _groups):
        args = []
        exits = []
        options = []
        switches = ''
        for action in actions:
            if not action.option_strings:
                get_metavar = self._get_default_metavar_for_positional
                args.append(get_metavar(action))
            elif 'exit' in action.help:
                exits.append(action.format_usage()[1:])
            elif action.nargs and action.nargs != 0:
                get_metavar = self._get_default_metavar_for_optional
                options.append('{} {}'.format(action.format_usage(),
                                              get_metavar(action)))
            else:
                switches += action.format_usage()[1:]
        args = ' '.join(args)
        exits = '[-{}]'.format('|'.join(exits))
        options = ' '.join(options)
        switches = '[-{}]'.format(switches)
        return ' '.join([exits, options, switches, args])

    def _get_default_metavar_for_optional(self, action):
        if action.nargs != 0:
            return f'<{action.dest}>'
        return f'[{action.dest}]'

    _get_default_metavar_for_positional = _get_default_metavar_for_optional


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-H', '--help-only', action='store_true',
            help='Generate only help text')
    parser.add_argument('-i', '--inject', action='store_true',
            help='Edit file inplace; Lines between xml2c:start and xml2c:end will be modified')
    parser.add_argument('-I', '--indent', type=int, default=0, metavar='WIDTH',
            help='Specify output indent width')
    parser.add_argument('-p', '--prefix', default='',
            help='Specify prefix of C constant names')
    parser.add_argument('INPUT', help='Input .mxml file')
    parser.add_argument('OUTPUT', help='Output file')
    args = parser.parse_args()
    indent = lambda text: textwrap.indent(text, ' ' * args.indent)
    with open(args.INPUT) as f:
        mdoc = Mdoc(f)
    if args.help_only:
        formatter = HelpFormatter(mdoc.prog, mdoc.desc, mdoc.options, mdoc.args)
        text = formatter.format_help()
    else:
        formatter = GetoptFormatter(args.INPUT, mdoc.prog, mdoc.desc, mdoc.options, mdoc.args, args.prefix)
        text = formatter.format_c_source()
    if args.inject:
        memory = io.StringIO()
        with open(args.OUTPUT, 'r') as f:
            skip = False
            for line in f:
                if 'xml2c:start' in line:
                    skip = True
                    memory.write(line)
                    memory.write(indent(text))
                elif 'xml2c:end' in line:
                    skip = False
                if not skip:
                    memory.write(line)
        memory.seek(0)
        with open(args.OUTPUT, 'w') as f:
            shutil.copyfileobj(memory, f)
    else:
        with open(args.OUTPUT, 'w+') as f:
            f.write(indent(text))
