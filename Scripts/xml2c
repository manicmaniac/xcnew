#!/usr/bin/env python3

import argparse
import collections
import io
import os
import shlex
import textwrap
import xml.etree.ElementTree as etree
import sys


Option = collections.namedtuple('Option', 'short long dest nargs help')
Arg = collections.namedtuple('Arg', 'name required help')


class Mdoc(object):
    def __init__(self, f):
        """
        >>> f = io.StringIO(_test_mxml)
        >>> mdoc = Mdoc(f)
        >>> mdoc.manpage is not None
        True
        >>> import pprint
        >>> pprint.pprint(mdoc.options)
        [Option(short='h', long='help', dest='', nargs=0, help='desc'),
         Option(short='i', long='id', dest='ID', nargs=1, help='desc')]
        >>> pprint.pprint(mdoc.args)
        [Arg(name='IN', required=True, help='desc'),
         Arg(name='OUT', required=False, help='desc')]
        """
        self.manpage = etree.parse(f).getroot()
        self.options = self._parse_options()
        self.args = self._parse_args()

    @property
    def prog(self):
        """
        >>> f = io.StringIO(_test_mxml)
        >>> Mdoc(f).prog
        'xcnew'
        """
        return self.manpage.find('names/name').text

    @property
    def desc(self):
        """
        >>> f = io.StringIO(_test_mxml)
        >>> Mdoc(f).desc
        'desc'
        """
        return self.manpage.find('names/name/desc').text

    def _parse_options(self):
        options = []
        for node in self.manpage.findall('usage/flag'):
            arg_node = node.find('arg')
            if arg_node is None:
                nargs, dest = 0, ''
            else:
                nargs, dest = 1, arg_node.text
            options.append(Option(
                short=node.text,
                long=node.find('long').text,
                dest=dest,
                nargs=nargs,
                help=node.find('desc').text
            ))
        return options

    def _parse_args(self):
        return [Arg(name=node.text,
                    required=(node.attrib.get('optional', '0') != '1'),
                    help=node.find('desc').text)
                for node in self.manpage.findall('usage/arg')]


class GetoptFormatter(object):
    def __init__(self, path, prog, desc, options, args, prefix, argv):
        self.path = path
        self.help_formatter = HelpFormatter(prog, desc, options, args)
        self.options = options
        self.args = args
        self.prefix = prefix
        self.argv = argv

    def format_c_source(self):
        """
        >>> formatter = GetoptFormatter('./', 'xcnew', 'desc', [], [], '', [])
        >>> '#include <getopt.h>' in formatter.format_c_source()
        True
        """
        return '\n'.join([
            self._format_header(),
            self._format_help(),
            self._format_short_options(),
            self._format_long_options()
        ])

    def _format_header(self):
        return textwrap.dedent("""\
            /**
             * This file is generated from {} with the following command.
             *
             *     {}
             *
             * DO NOT edit this file directly.
             */

            #include <getopt.h>
            """).format(self.path, shlex.join(self.argv))

    def _format_help(self):
        decl = f'const char {self.prefix}Help[] = '
        indent_width = len(decl)
        help_lines = self.help_formatter.format_help().splitlines()
        lines = []
        for i, line in enumerate(help_lines):
            if i == 0:
                line = f'const char {self.prefix}Help[] = "{line}\\n"'
            elif i == len(help_lines) - 1:
                line = ' ' * indent_width + f'"{line}";\n'
            else:
                line = ' ' * indent_width + f'"{line}\\n"'
            lines.append(line)
        return '\n'.join(lines)

    def _format_short_options(self):
        chars = ''
        for option in self.options:
            chars += option.short
            if option.nargs != 0:
                chars += ':'
        return f'const char {self.prefix}ShortOptions[] = "{chars}";\n'

    def _format_long_options(self):
        lines = [f'const struct option {self.prefix}LongOptions[] = {{']
        for option in self.options:
            short = option.short
            long = option.long
            if option.nargs == 0:
                flag = 'no_argument'
            else:
                flag = 'required_argument'
            lines.append(f'    {{"{long}", {flag}, NULL, \'{short}\'}},')
        lines.append('    {NULL, 0, NULL, 0},')
        lines.append('};\n')
        return '\n'.join(lines)


class HelpFormatter(argparse.HelpFormatter):
    def __init__(self, prog, desc, options, args):
        super().__init__(prog, indent_increment=4, max_help_position=30)
        options = [self._option_to_action(option) for option in options]
        args = [self._arg_to_action(arg) for arg in args]
        self.add_text(f'{self._prog} - {desc}\n')
        self.add_usage(None, options + args, [], prefix='Usage: ')
        self.start_section('Options')
        self.add_arguments(options)
        self.end_section()
        self.start_section('Arguments')
        self.add_arguments(args)
        self.end_section()

    @staticmethod
    def _option_to_action(option):
        return argparse.Action(['-' + option.short, '--' + option.long],
                               option.dest, nargs=option.nargs,
                               help=option.help)

    @staticmethod
    def _arg_to_action(arg):
        return argparse.Action([], arg.name, nargs=int(arg.required),
                               required=arg.required, help=arg.help)

    def _format_actions_usage(self, actions, _groups):
        args = []
        exits = []
        options = []
        switches = ''
        for action in actions:
            if not action.option_strings:
                get_metavar = self._get_default_metavar_for_positional
                args.append(get_metavar(action))
            elif 'exit' in action.help:
                exits.append(action.format_usage()[1:])
            elif action.nargs and action.nargs != 0:
                get_metavar = self._get_default_metavar_for_optional
                short = action.format_usage()
                metavar = get_metavar(action)
                options.append(f'[{short} {metavar}]')
            else:
                switches += action.format_usage()[1:]
        args = ' '.join(args)
        exit_contents = '|'.join(exits)
        exits = f'[-{exit_contents}]'
        options = ' '.join(options)
        switches = f'[-{switches}]'
        return ' '.join([exits, options, switches, args])

    def _get_default_metavar_for_optional(self, action):
        if action.nargs != 0:
            return f'<{action.dest}>'
        return f'[{action.dest}]'

    _get_default_metavar_for_positional = _get_default_metavar_for_optional


def _main(argv=sys.argv):
    if os.getenv('DOCTEST') == '1':
        import doctest
        return doctest.testmod()[0] > 0
    parser = argparse.ArgumentParser()
    parser.add_argument('-H', '--help-only', action='store_true',
                        help='Generate only help text')
    parser.add_argument('-i', '--inject', action='store_true',
                        help='Edit file inplace; Lines between xml2c:start ' +
                             'and xml2c:end will be modified')
    parser.add_argument('-I', '--indent', type=int, default=0, metavar='WIDTH',
                        help='Specify output indent width')
    parser.add_argument('-p', '--prefix', default='',
                        help='Specify prefix of C constant names')
    parser.add_argument('INPUT', help='Input .mxml file')
    parser.add_argument('OUTPUT', help='Output file')
    args = parser.parse_args(argv[1:])

    def indent(text):
        return textwrap.indent(text, ' ' * args.indent)

    with open(args.INPUT) as f:
        mdoc = Mdoc(f)
    if args.help_only:
        formatter = HelpFormatter(mdoc.prog, mdoc.desc, mdoc.options,
                                  mdoc.args)
        text = formatter.format_help()
    else:
        formatter = GetoptFormatter(args.INPUT, mdoc.prog, mdoc.desc,
                                    mdoc.options, mdoc.args, args.prefix, argv)
        text = formatter.format_c_source()
    if args.inject:
        memory = io.StringIO()
        with open(args.OUTPUT, 'r') as f:
            skip = False
            for line in f:
                if 'xml2c:start' in line:
                    skip = True
                    memory.write(line)
                    memory.write(indent(text))
                elif 'xml2c:end' in line:
                    skip = False
                if not skip:
                    memory.write(line)
        memory.seek(0)
        with open(args.OUTPUT, 'w') as f:
            f.write(memory.read())
    else:
        with open(args.OUTPUT, 'w+') as f:
            f.write(indent(text))


_test_mxml = """<?xml version="1.0" encoding="UTF-8"?>
<manpage>
  <names>
    <name>xcnew<desc>desc</desc></name>
  </names>
  <usage>
    <flag optional="1">h<long>help</long><desc>desc</desc></flag>
    <flag optional="1">i<long>id</long><arg>ID</arg><desc>desc</desc></flag>
    <arg>IN<desc>desc</desc></arg>
    <arg optional="1">OUT<desc>desc</desc></arg>
  </usage>
</manpage>
"""


if __name__ == '__main__':
    sys.exit(_main())
